<!doctype html>
<html lang="ja" data-theme="light">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>文字情報基盤比較システム</title>
  <!-- __GA_SCRIPT__ -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <style>
    /* レイアウト */
    header {
      margin-bottom: var(--pico-block-spacing-vertical);
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--pico-spacing);
    }

    .header-row h1 {
      margin-bottom: 0;
    }

    .compare-inputs {
      display: flex;
      gap: var(--pico-spacing);
      align-items: center;
      margin-bottom: var(--pico-block-spacing-vertical);
    }

    .compare-inputs input[type="search"] {
      font-size: 1.5rem;
      max-width: 18rem;
      margin-bottom: 0;
    }

    footer {
      margin-top: calc(var(--pico-block-spacing-vertical) * 2);
      padding-top: var(--pico-spacing);
      border-top: 1px solid var(--pico-muted-border-color);
    }

    /* テーブル */
    .compare-table {
      font-size: 0.875rem;
    }

    .compare-table th:first-child {
      text-align: left;
      font-weight: normal;
      color: var(--pico-muted-color);
      min-width: 140px;
      position: sticky;
      left: 0;
      background: var(--pico-card-background-color);
    }

    .compare-table th:not(:first-child) {
      text-align: center;
      min-width: 100px;
    }

    .compare-table td {
      font-family: monospace;
      text-align: center;
    }

    .compare-table td.match {
      background: color-mix(in srgb, var(--pico-ins-color) 10%, transparent);
    }

    .compare-table td.diff {
      background: color-mix(in srgb, var(--pico-del-color) 10%, transparent);
    }

    .compare-table thead th {
      vertical-align: bottom;
    }

    /* MJ画像 */
    .mj-img {
      background: white;
      border-radius: var(--pico-border-radius);
      padding: 0.25rem;
    }

    .mj-img-primary {
      outline: 3px solid var(--pico-primary);
      outline-offset: 2px;
      box-shadow: 0 0 8px var(--pico-primary);
    }

    /* Copyボタン */
    .copy-btn {
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      margin-top: 0.25rem;
      border: 1px solid var(--pico-muted-border-color);
      border-radius: var(--pico-border-radius);
      background: transparent;
      color: var(--pico-muted-color);
      cursor: pointer;
    }

    .copy-btn:hover {
      border-color: var(--pico-primary);
      color: var(--pico-primary);
    }

    .copy-btn.copied {
      border-color: var(--pico-ins-color);
      color: var(--pico-ins-color);
    }

    /* リスト共通 */
    .char-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .char-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      border: 1px solid var(--pico-muted-border-color);
      border-radius: var(--pico-border-radius);
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      min-width: 4rem;
    }

    .char-item:hover {
      border-color: var(--pico-primary);
      background: color-mix(in srgb, var(--pico-primary) 5%, transparent);
    }

    .char-item.small {
      min-width: 2.5rem;
      width: 2.5rem;
      height: 2.5rem;
      justify-content: center;
    }

    .char-item .char {
      font-size: 1.5rem;
    }

    .char-item.small .char {
      font-size: 1.25rem;
    }

    /* セクション */
    .history-section,
    .candidates-section,
    .related-section {
      margin-bottom: var(--pico-block-spacing-vertical);
    }

    .history-header {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .history-reset-btn {
      background: transparent;
      border: none;
      color: var(--pico-muted-color);
      cursor: pointer;
      padding: 0;
      display: flex;
    }

    .history-reset-btn:hover {
      color: var(--pico-del-color);
    }

    /* トグル */
    .compare-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: var(--pico-muted-color);
      cursor: pointer;
      margin-bottom: 0;
    }

    .compare-toggle input[type="checkbox"] {
      margin: 0;
    }

    /* 空状態・その他 */
    #main-empty {
      color: var(--pico-muted-color);
      font-style: italic;
    }

    .compare-vs {
      font-size: 1.25rem;
      color: var(--pico-muted-color);
    }

    .clickable-ucs {
      cursor: pointer;
      color: var(--pico-primary);
      text-decoration: underline;
    }

    .network-graph {
      margin-top: 0.5rem;
      width: 100%;
      border-radius: var(--pico-border-radius);
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    }

    .network-tooltip {
      position: fixed;
      padding: 0.4rem 0.6rem;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 4px;
      font-size: 0.7rem;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <main class="container">
    <header>
      <div class="header-row">
        <h1>文字情報基盤比較システム</h1>
        <label class="compare-toggle">
          <input type="checkbox" id="compare-toggle" role="switch">
          比較モード
        </label>
      </div>
      <p id="db-status" aria-busy="true">MJ文字情報を読み込み中...</p>
    </header>

    <div class="compare-inputs">
      <input type="search" id="input-char" maxlength="10" placeholder="文字 / MJ番号 / 読み" autofocus />
      <span id="compare-vs" class="compare-vs" hidden>vs</span>
      <input type="search" id="input-char2" maxlength="10" placeholder="比較する文字" hidden />
    </div>

    <section id="history-section" class="history-section" hidden>
      <div class="history-header">
        <small>最近の検索</small>
        <button id="history-reset" class="history-reset-btn" title="履歴をクリア"><svg width="12" height="12"
            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18" />
            <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" />
          </svg></button>
      </div>
      <ul class="char-list" id="history-list"></ul>
    </section>

    <section id="candidates-section" class="candidates-section" hidden>
      <small id="candidates-label">読み検索結果:</small>
      <ul class="char-list" id="candidates-list"></ul>
    </section>

    <section id="main-section">
      <p id="main-empty">文字を入力してください</p>
      <figure id="variants-section" hidden>
        <table class="compare-table">
          <thead id="variants-header"></thead>
          <tbody id="variants-body"></tbody>
        </table>
      </figure>
    </section>

    <section id="related-section" class="related-section" hidden>
      <small>関連する文字</small>
      <div id="network-graph" class="network-graph"></div>
    </section>

  </main>

  <footer class="container">
    <small>
      本ツールは<a href="https://moji.or.jp/mojikiban/mjlist/" target="_blank" rel="noopener">MJ文字情報一覧表 Ver.006.02</a>および<a
        href="https://moji.or.jp/mojikiban/map/" target="_blank" rel="noopener">MJ縮退マップ Ver.1.2.0</a>（IPA）を利用しています。
    </small>
    <!-- __GA_PRIVACY__ -->
  </footer>

  <script type="module">
    import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm';

    const inputChar = document.getElementById('input-char');
    const mainEmpty = document.getElementById('main-empty');
    const variantsSection = document.getElementById('variants-section');
    const variantsHeader = document.getElementById('variants-header');
    const variantsBody = document.getElementById('variants-body');
    const candidatesSection = document.getElementById('candidates-section');
    const candidatesList = document.getElementById('candidates-list');
    const candidatesLabel = document.getElementById('candidates-label');
    const historySection = document.getElementById('history-section');
    const historyList = document.getElementById('history-list');
    const historyReset = document.getElementById('history-reset');
    const inputChar2 = document.getElementById('input-char2');
    const compareToggle = document.getElementById('compare-toggle');
    const compareVs = document.getElementById('compare-vs');
    const relatedSection = document.getElementById('related-section');

    let compareMode = false;
    let lastFocusedInput = inputChar;

    inputChar.addEventListener('focus', () => lastFocusedInput = inputChar);
    inputChar2.addEventListener('focus', () => lastFocusedInput = inputChar2);

    const getTargetInput = () => compareMode && lastFocusedInput === inputChar2 ? inputChar2 : inputChar;

    const showEmpty = (message) => {
      mainEmpty.hidden = false;
      mainEmpty.textContent = message;
    };

    const clearTable = () => {
      variantsHeader.textContent = '';
      variantsBody.textContent = '';
    };

    const setInputAndUpdate = (value) => {
      getTargetInput().value = value;
      updateUrl(inputChar.value, inputChar2.value);
      update();
    };

    const HISTORY_KEY = 'mj-viewer-history';
    const MAX_HISTORY = 20;

    // アイコン
    const ICON_COPY = '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy';
    const ICON_CHECK = '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> Copied!';

    // GA4 event
    const trackSearch = (searchTerm) => {
      if (typeof gtag !== 'undefined') {
        gtag('event', 'search', { search_term: searchTerm });
      }
    };

    const getHistory = () => {
      try {
        const raw = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
        return raw.map((item) => typeof item === 'string' ? { char: item, mjName: null } : item);
      } catch {
        return [];
      }
    };

    const addToHistory = (char, mjName = null) => {
      if (!char || isMjName(char) || isReading(char)) return;
      const history = getHistory().filter((item) => item.char !== char);
      history.unshift({ char, mjName });
      if (history.length > MAX_HISTORY) history.pop();
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      renderHistory();
    };

    const renderHistory = () => {
      const history = getHistory();
      historySection.hidden = history.length === 0;
      historyList.textContent = '';

      for (const { char, mjName } of history) {
        const li = document.createElement('li');
        li.className = 'char-item small';
        const imgUrl = getMjImageUrl(mjName);
        if (imgUrl) {
          li.innerHTML = `<img src="${imgUrl}" alt="${mjName}" class="mj-img" style="height:1.5rem">`;
        } else {
          li.innerHTML = `<span class="char">${char}</span>`;
        }
        li.title = char;
        li.addEventListener('click', () => setInputAndUpdate(char));
        historyList.appendChild(li);
      }
    };

    const clearHistory = () => {
      localStorage.removeItem(HISTORY_KEY);
      renderHistory();
    };

    historyReset.addEventListener('click', clearHistory);

    let conn = null;
    let shrinkMap = null;
    let ucsToMjNames = null;

    // 縮退マップのフィールド定義（key: JSONキー, label: 表示ラベル, color: エッジ色）
    const SHRINK_FIELDS = [
      { key: 'JIS包摂規準・UCS統合規則', label: 'JIS包摂', color: '#64b5f6' },
      { key: '辞書類等による関連字', label: '辞書類', color: '#81c784' },
      { key: '法務省告示582号別表第四', label: '告示', color: '#ffb74d' },
      { key: '法務省戸籍法関連通達・通知', label: '戸籍法', color: '#ce93d8' },
      { key: '読み・字形による類推', label: '類推', color: '#f48fb1' }
    ];
    const EDGE_COLORS = Object.fromEntries(SHRINK_FIELDS.map(f => [f.label, f.color]));

    const initShrinkMap = async () => {
      const response = await fetch('MJShrinkMapVer.1.2.0/MJShrinkMap.1.2.0.json');
      const data = await response.json();
      shrinkMap = new Map(data.content.map(entry => [entry.MJ文字図形名, entry]));

      // UCSからMJ文字図形名への逆引きMapを作成
      ucsToMjNames = new Map();
      for (const entry of data.content) {
        const mjName = entry.MJ文字図形名;
        for (const { key } of SHRINK_FIELDS) {
          if (entry[key]) {
            for (const item of entry[key]) {
              if (item.UCS) {
                if (!ucsToMjNames.has(item.UCS)) {
                  ucsToMjNames.set(item.UCS, []);
                }
                if (!ucsToMjNames.get(item.UCS).includes(mjName)) {
                  ucsToMjNames.get(item.UCS).push(mjName);
                }
              }
            }
          }
        }
      }
      console.log('ShrinkMap initialized');
    };

    const getRelatedUcs = (mjName) => {
      if (!shrinkMap || !mjName) return [];
      const entry = shrinkMap.get(mjName);
      if (!entry) return [];

      const ucsSet = new Set();
      for (const { key } of SHRINK_FIELDS) {
        if (entry[key]) {
          for (const item of entry[key]) {
            if (item.UCS) ucsSet.add(item.UCS);
          }
        }
      }
      return [...ucsSet];
    };

    const MJ_FIELDS = [
      { key: 'MJ文字図形名', label: 'MJ文字図形名' },
      { key: '対応するUCS', label: '対応するUCS' },
      { key: 'UnicodeBlock', label: 'Unicodeブロック', computed: true },
      { key: '実装したUCS', label: '実装したUCS' },
      { key: '実装したMoji_JohoコレクションIVS', label: '実装したIVS' },
      { key: 'X0213', label: 'JIS X 0213' },
      { key: 'X0213_level', label: 'JIS X 0213 水準', computed: true },
      { key: 'X0213 包摂区分', label: 'JIS X 0213 包摂区分' },
      { key: 'X0213 包摂連番', label: 'JIS X 0213 包摂連番' },
      { key: 'X0212', label: 'JIS X 0212' },
      { key: '戸籍統一文字番号', label: '戸籍統一文字番号' },
      { key: '住基ネット統一文字コード', label: '住基ネット統一文字コード' },
      { key: '入管正字コード', label: '入管正字コード' },
      { key: '漢字施策', label: '漢字施策' },
      { key: '対応する互換漢字', label: '対応する互換漢字' },
      { key: '総画数(参考)', label: '総画数' },
      { key: '部首1(参考)', label: '部首' },
      { key: '内画数1(参考)', label: '内画数' },
      { key: '読み(参考)', label: '読み' },
    ];

    const calcJisLevel = (x0213) => {
      if (!x0213) return '';
      const match = x0213.match(/^(\d)-(\d+)-(\d+)$/);
      if (!match) return '';

      const [, men, ku] = match.map(Number);

      if (men === 1) {
        if (ku >= 1 && ku <= 8) return '非漢字';
        if (ku >= 16 && ku <= 47) return '1';
        if (ku >= 48 && ku <= 84) return '2';
        return '3';
      }
      if (men === 2) return '4';
      return '';
    };

    const getUnicodeBlock = (ucs) => {
      if (!ucs) return '';
      const code = parseInt(ucs.replace('U+', ''), 16);
      if (isNaN(code)) return '';

      // CJK関連のUnicodeブロック
      if (code >= 0x4E00 && code <= 0x9FFF) return 'CJK統合漢字';
      if (code >= 0x3400 && code <= 0x4DBF) return 'CJK統合漢字拡張A';
      if (code >= 0x20000 && code <= 0x2A6DF) return 'CJK統合漢字拡張B';
      if (code >= 0x2A700 && code <= 0x2B73F) return 'CJK統合漢字拡張C';
      if (code >= 0x2B740 && code <= 0x2B81F) return 'CJK統合漢字拡張D';
      if (code >= 0x2B820 && code <= 0x2CEAF) return 'CJK統合漢字拡張E';
      if (code >= 0x2CEB0 && code <= 0x2EBEF) return 'CJK統合漢字拡張F';
      if (code >= 0x30000 && code <= 0x3134F) return 'CJK統合漢字拡張G';
      if (code >= 0x31350 && code <= 0x323AF) return 'CJK統合漢字拡張H';
      if (code >= 0xF900 && code <= 0xFAFF) return 'CJK互換漢字';
      if (code >= 0x2F800 && code <= 0x2FA1F) return 'CJK互換漢字補助';
      if (code >= 0x2F00 && code <= 0x2FDF) return '康煕部首';
      if (code >= 0x2E80 && code <= 0x2EFF) return 'CJK部首補助';
      if (code >= 0x3000 && code <= 0x303F) return 'CJK記号・句読点';

      return '';
    };

    // 共通ヘルパー
    const SQL_COLUMNS = MJ_FIELDS.filter((f) => !f.computed).map((f) => `"${f.key}"`).join(', ');
    const ucsToChar = (ucs) => ucs ? String.fromCodePoint(parseInt(ucs.replace('U+', ''), 16)) : null;
    const getDisplayChar = (data, fallback = '?') => ucsToChar(data['実装したUCS'] || data['対応するUCS']) || fallback;
    const formatValue = (v) => (v === '' || v == null) ? '-' : v;
    const mapQueryResult = (result) => result.toArray().map((row) => {
      const data = {};
      for (const field of MJ_FIELDS) {
        if (!field.computed) data[field.key] = row[field.key];
      }
      data.font = row.font;
      data['X0213_level'] = calcJisLevel(data['X0213']);
      data['UnicodeBlock'] = getUnicodeBlock(data['対応するUCS']);
      return data;
    });

    const initDuckDB = async () => {
      const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
      const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);

      const workerUrl = URL.createObjectURL(
        new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
      );

      const worker = new Worker(workerUrl);
      const logger = new duckdb.ConsoleLogger();
      const db = new duckdb.AsyncDuckDB(logger, worker);
      await db.instantiate(bundle.mainModule);
      URL.revokeObjectURL(workerUrl);
      conn = await db.connect();

      const csvResponse = await fetch('mji.00602.csv');
      const csvBuffer = await csvResponse.arrayBuffer();
      await db.registerFileBuffer('mji.csv', new Uint8Array(csvBuffer));

      await conn.query(`
          CREATE TABLE mji AS
          SELECT * FROM read_csv_auto('mji.csv')
        `);

      console.log('DuckDB initialized');
    };

    const parseInput = (input) => {
      const chars = Array.from(input);
      if (!chars.length) return { ucs: null, ivs: null };

      const base = chars[0].codePointAt(0);
      const ucs = `U+${base.toString(16).toUpperCase().padStart(4, '0')}`;

      // IVS: 2文字目が異体字セレクタ (U+E0100〜U+E01EF) の場合
      if (chars.length >= 2) {
        const vs = chars[1].codePointAt(0);
        if (vs >= 0xE0100 && vs <= 0xE01EF) {
          const ivs = `${base.toString(16).toUpperCase()}_${vs.toString(16).toUpperCase()}`;
          return { ucs, ivs };
        }
      }

      return { ucs, ivs: null };
    };

    const queryByUcs = async (ucs, ivs = null) => {
      if (!conn || !ucs) return [];
      const ivsCondition = ivs ? ` OR "実装したMoji_JohoコレクションIVS" = '${ivs}'` : '';
      const result = await conn.query(`
          SELECT ${SQL_COLUMNS}, font FROM mji
          WHERE "対応するUCS" IN (
            SELECT "対応するUCS" FROM mji
            WHERE "対応するUCS" = '${ucs}' OR "実装したUCS" = '${ucs}'${ivsCondition}
          )
        `);
      return mapQueryResult(result);
    };

    const queryByMjName = async (mjName) => {
      if (!conn || !mjName) return [];
      const result = await conn.query(`
          SELECT ${SQL_COLUMNS}, font FROM mji
          WHERE "対応するUCS" IN (
            SELECT "対応するUCS" FROM mji WHERE "MJ文字図形名" = '${mjName}'
          )
        `);
      return mapQueryResult(result);
    };

    const isMjName = (input) => /^MJ\d{6}$/i.test(input.trim());
    const isReading = (input) => /^[\u3040-\u309F\u30A0-\u30FF]+$/.test(input.trim());

    const queryByReading = async (reading) => {
      if (!conn || !reading) return [];
      const hiragana = reading.replace(/[\u30A0-\u30FF]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) - 0x60));
      const katakana = reading.replace(/[\u3040-\u309F]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) + 0x60));
      const result = await conn.query(`
          SELECT DISTINCT ${SQL_COLUMNS}, font FROM mji
          WHERE "読み(参考)" LIKE '${hiragana}%' OR "読み(参考)" LIKE '${katakana}%'
             OR "読み(参考)" LIKE '%・${hiragana}%' OR "読み(参考)" LIKE '%・${katakana}%'
          LIMIT 50
        `);
      return mapQueryResult(result);
    };

    const getMjImageUrl = (mjName) => {
      if (!mjName) return null;
      return `https://moji.or.jp/mojikibansearch/img/MJ/${mjName}.png`;
    };

    const copyToClipboard = async (text, btn) => {
      try {
        await navigator.clipboard.writeText(text);
        btn.innerHTML = ICON_CHECK;
        btn.classList.add('copied');
        setTimeout(() => {
          btn.innerHTML = ICON_COPY;
          btn.classList.remove('copied');
        }, 1500);
      } catch (err) {
        console.error('Copy failed:', err);
      }
    };

    const getCopyChar = (data, fallback) => {
      const ivs = data['実装したMoji_JohoコレクションIVS'];
      if (ivs) {
        const [baseHex, vsHex] = ivs.split('_');
        return String.fromCodePoint(parseInt(baseHex, 16), parseInt(vsHex, 16));
      }
      return getDisplayChar(data, fallback);
    };

    const isPrimaryResult = (data, inputUcs, inputIvs, inputMjName) =>
      inputMjName ? data['MJ文字図形名'] === inputMjName
        : inputIvs ? data['実装したMoji_JohoコレクションIVS'] === inputIvs
          : data['実装したUCS'] === inputUcs;

    const createClickableUcs = (value) => {
      const span = document.createElement('span');
      span.className = 'clickable-ucs';
      span.textContent = value;
      span.addEventListener('click', () => setInputAndUpdate(ucsToChar(value)));
      return span;
    };

    const createHeaderCellHtml = (mjName, imgUrl, displayChar, isPrimary = false) => {
      if (imgUrl) {
        const imgClass = isPrimary ? 'mj-img mj-img-primary' : 'mj-img';
        return `<img src="${imgUrl}" alt="${mjName}" class="${imgClass}" style="height:2.5rem;vertical-align:middle;"><div style="font-size:0.7rem">${mjName}</div>`;
      }
      return `<div style="font-size:1.5rem">${displayChar}</div><div style="font-size:0.7rem">${mjName || ''}</div>`;
    };

    const renderVariantsTable = (results, char, inputUcs, inputIvs = null, inputMjName = null) => {
      clearTable();

      const headerRow = document.createElement('tr');
      headerRow.innerHTML = '<th>項目</th>';

      for (const data of results) {
        const th = document.createElement('th');
        const mjName = data['MJ文字図形名'];
        const isPrimary = isPrimaryResult(data, inputUcs, inputIvs, inputMjName);
        const displayChar = getDisplayChar(data, char);
        th.innerHTML = createHeaderCellHtml(mjName, getMjImageUrl(mjName), displayChar, isPrimary);

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.innerHTML = ICON_COPY;
        copyBtn.addEventListener('click', () => copyToClipboard(getCopyChar(data, char), copyBtn));
        th.appendChild(copyBtn);
        headerRow.appendChild(th);
      }
      variantsHeader.appendChild(headerRow);

      const primaryIndex = results.findIndex((d) => isPrimaryResult(d, inputUcs, inputIvs, inputMjName));
      const clickableFields = ['対応する互換漢字', '対応するUCS', '実装したUCS'];

      for (const field of MJ_FIELDS) {
        const values = results.map((d) => formatValue(d[field.key]));
        const tr = document.createElement('tr');
        tr.innerHTML = `<th>${field.label}</th>`;

        const primaryValue = primaryIndex >= 0 ? values[primaryIndex] : null;

        for (const value of values) {
          const td = document.createElement('td');
          if (clickableFields.includes(field.key) && value !== '-' && value.startsWith('U+')) {
            td.appendChild(createClickableUcs(value));
          } else {
            td.textContent = value;
          }
          if (results.length > 1 && primaryValue !== null) {
            td.classList.add(value === primaryValue ? 'match' : 'diff');
          }
          tr.appendChild(td);
        }
        variantsBody.appendChild(tr);
      }
    };

    const renderCandidates = (results, reading) => {
      candidatesList.textContent = '';
      candidatesLabel.textContent = `「${reading}」の検索結果 (${results.length}件):`;

      for (const data of results) {
        const li = document.createElement('li');
        li.className = 'char-item';
        const displayChar = getDisplayChar(data);
        const mjName = data['MJ文字図形名'] || '';
        const imgUrl = getMjImageUrl(mjName);

        if (imgUrl) {
          li.innerHTML = `<img src="${imgUrl}" alt="${mjName}" class="mj-img" style="height:2rem"><small style="font-size:0.6rem;color:var(--pico-muted-color)">${mjName}</small>`;
        } else {
          li.innerHTML = `<span class="char">${displayChar}</span><small style="font-size:0.6rem;color:var(--pico-muted-color)">${mjName}</small>`;
        }
        li.addEventListener('click', () => setInputAndUpdate(displayChar));
        candidatesList.appendChild(li);
      }
    };

    // 縮退マップから関連MJ文字図形名を収集（MJ文字図形名ベース）
    const collectRelatedMjNames = (startMjNames, maxDepth = 2) => {
      const visitedMj = new Set();
      const allUcs = new Set();

      const processQueue = [...startMjNames];

      for (let depth = 0; depth < maxDepth && processQueue.length > 0; depth++) {
        const currentBatch = processQueue.splice(0, processQueue.length);

        for (const mjName of currentBatch) {
          if (visitedMj.has(mjName)) continue;
          visitedMj.add(mjName);

          const relatedUcsList = getRelatedUcs(mjName);
          for (const ucs of relatedUcsList) {
            allUcs.add(ucs);

            if (ucsToMjNames) {
              const otherMjNames = ucsToMjNames.get(ucs) || [];
              for (const otherMj of otherMjNames) {
                if (!visitedMj.has(otherMj)) {
                  processQueue.push(otherMj);
                }
              }
            }
          }
        }
      }

      return { mjNames: [...visitedMj], relatedUcs: [...allUcs] };
    };

    // 縮退マップから関連エッジを収集（ネットワーク図用）
    const collectRelatedEdges = (mjNames) => {
      const edges = [];
      const ucsSet = new Set();

      for (const mjName of mjNames) {
        if (!shrinkMap) continue;
        const entry = shrinkMap.get(mjName);
        if (!entry) continue;

        for (const { key, label } of SHRINK_FIELDS) {
          if (entry[key]) {
            for (const item of entry[key]) {
              if (item.UCS) {
                ucsSet.add(item.UCS);
                edges.push({ from: mjName, to: item.UCS, type: label });
              }
            }
          }
        }
      }

      return { edges, ucsNodes: [...ucsSet] };
    };

    // 複数のUCSから全MJ文字図形を取得
    const queryAllByUcsList = async (ucsList) => {
      if (!conn || ucsList.length === 0) return [];
      const ucsConditions = ucsList.map(ucs => `'${ucs}'`).join(', ');
      const result = await conn.query(`
        SELECT ${SQL_COLUMNS}, font FROM mji
        WHERE "対応するUCS" IN (${ucsConditions})
      `);
      return mapQueryResult(result);
    };

    // 複数のMJ文字図形名から全データを取得
    const queryAllByMjNames = async (mjNames) => {
      if (!conn || mjNames.length === 0) return [];
      const mjConditions = mjNames.map(mj => `'${mj}'`).join(', ');
      const result = await conn.query(`
        SELECT ${SQL_COLUMNS}, font FROM mji
        WHERE "MJ文字図形名" IN (${mjConditions})
      `);
      return mapQueryResult(result);
    };

    const renderRelated = async (results, inputUcs, inputIvs, inputMjName) => {
      // 関連MJ文字図形名と関連UCSを収集（縮退マップベース）
      const currentMjNames = results.map(d => d['MJ文字図形名']).filter(Boolean);
      const { mjNames: relatedMjNames, relatedUcs } = collectRelatedMjNames(currentMjNames);
      const currentUcs = results.map(d => d['対応するUCS']).filter(Boolean);
      const allUcs = [...new Set([...currentUcs, ...relatedUcs])];

      const hasRelated = relatedMjNames.length > 0 || allUcs.length > 0;
      relatedSection.hidden = !hasRelated;
      if (!hasRelated) return;

      // 縮退マップのMJ文字図形名 + 関連UCSの対応するUCSで全データを取得
      const [mjResults, ucsResults] = await Promise.all([
        queryAllByMjNames([...new Set([...currentMjNames, ...relatedMjNames])]),
        queryAllByUcsList(allUcs)
      ]);

      // 重複を除去して統合
      const seenMjNames = new Set();
      const allResults = [];
      for (const r of [...mjResults, ...ucsResults]) {
        if (!seenMjNames.has(r['MJ文字図形名'])) {
          seenMjNames.add(r['MJ文字図形名']);
          allResults.push(r);
        }
      }

      // ネットワーク図を生成（D3.js）
      const networkGraph = document.getElementById('network-graph');
      if (networkGraph && allResults.length > 0 && typeof d3 !== 'undefined') {
        const { edges: shrinkEdges } = collectRelatedEdges(allResults.map(r => r['MJ文字図形名']));

        // UCSごとにMJ文字図形をグループ化
        const ucsToMjMap = new Map();
        for (const r of allResults) {
          const ucs = r['対応するUCS'];
          if (!ucsToMjMap.has(ucs)) {
            ucsToMjMap.set(ucs, []);
          }
          ucsToMjMap.get(ucs).push(r);
        }

        // 検索した文字を特定
        const primaryResult = results.find(d => isPrimaryResult(d, inputUcs, inputIvs, inputMjName));
        const primaryMjName = primaryResult ? primaryResult['MJ文字図形名'] : null;
        const searchedMjSet = new Set(primaryMjName ? [primaryMjName] : []);
        const primaryColor = '#1976d2';
        const relatedColor = '#9e9e9e';

        // ツールチップ要素を作成
        let tooltip = document.querySelector('.network-tooltip');
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.className = 'network-tooltip';
          tooltip.style.display = 'none';
          document.body.appendChild(tooltip);
        }
        const showTooltip = (event, html) => {
          tooltip.innerHTML = html;
          tooltip.style.display = 'block';
          tooltip.style.left = `${event.clientX + 12}px`;
          tooltip.style.top = `${event.clientY - 10}px`;
        };
        const moveTooltip = (event) => {
          tooltip.style.left = `${event.clientX + 12}px`;
          tooltip.style.top = `${event.clientY - 10}px`;
        };
        const hideTooltip = () => { tooltip.style.display = 'none'; };

        // ノードデータを作成
        const nodes = [];
        const nodeMap = new Map();
        for (const [ucs, mjList] of ucsToMjMap) {
          for (const mj of mjList) {
            const mjName = mj['MJ文字図形名'];
            const isSearched = searchedMjSet.has(mjName);
            const node = {
              id: mjName,
              ucs: ucs,
              imgUrl: getMjImageUrl(mjName),
              isSearched,
              color: isSearched ? primaryColor : relatedColor,
              size: isSearched ? 48 : 32
            };
            nodes.push(node);
            nodeMap.set(mjName, node);
          }
        }

        // エッジデータを作成
        const links = [];
        const mjEdgeSet = new Set();
        for (const edge of shrinkEdges) {
          const fromMj = edge.from;
          const toUcs = edge.to;
          const edgeColor = EDGE_COLORS[edge.type] || '#999';
          const toMjList = ucsToMjMap.get(toUcs) || [];
          for (const toMjData of toMjList) {
            const toMj = toMjData['MJ文字図形名'];
            if (fromMj !== toMj && nodeMap.has(fromMj) && nodeMap.has(toMj)) {
              const edgeKey = [fromMj, toMj].sort().join('-') + '-' + edge.type;
              if (!mjEdgeSet.has(edgeKey)) {
                mjEdgeSet.add(edgeKey);
                links.push({
                  source: fromMj,
                  target: toMj,
                  type: edge.type,
                  color: edgeColor
                });
              }
            }
          }
        }

        // SVGをクリア＆作成
        networkGraph.innerHTML = '';
        const width = networkGraph.clientWidth;
        const height = Math.min(width * 0.6, 600);
        networkGraph.style.height = `${height}px`;
        const centerX = width / 2;
        const centerY = height / 2;

        const svg = d3.select(networkGraph)
          .append('svg')
          .attr('width', width)
          .attr('height', height)
          .attr('viewBox', [0, 0, width, height]);

        // ズーム・パン対応
        const g = svg.append('g');
        svg.call(d3.zoom()
          .scaleExtent([0.3, 3])
          .on('zoom', (event) => g.attr('transform', event.transform)));

        // 矢印マーカー定義
        const defs = svg.append('defs');
        Object.entries(EDGE_COLORS).forEach(([type, color]) => {
          defs.append('marker')
            .attr('id', `arrow-${type}`)
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 12)
            .attr('refY', 0)
            .attr('markerWidth', 5)
            .attr('markerHeight', 5)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', color);
        });

        // Force simulation
        const simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id).distance(120).strength(0.5))
          .force('charge', d3.forceManyBody().strength(-300))
          .force('x', d3.forceX(centerX).strength(0.05))
          .force('y', d3.forceY(centerY).strength(0.05))
          .force('collision', d3.forceCollide().radius(d => d.size + 10));

        // 検索文字を中央に固定
        nodes.forEach(node => {
          if (node.isSearched) {
            node.fx = centerX;
            node.fy = centerY;
          }
        });

        // エッジ描画（曲線）+ 出現アニメーション
        const link = g.append('g')
          .attr('class', 'links')
          .selectAll('path')
          .data(links)
          .join('path')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('stroke-opacity', 0)
          .attr('fill', 'none')
          .attr('marker-end', d => `url(#arrow-${d.type})`)
          .attr('stroke-dasharray', '5,3');

        // エッジの出現アニメーション
        link.transition()
          .delay((d, i) => Math.min(i * 5, 100))
          .duration(300)
          .attr('stroke-opacity', 0.6);

        // ノード描画（画像 + 枠線）
        const node = g.append('g')
          .attr('class', 'nodes')
          .selectAll('g')
          .data(nodes)
          .join('g')
          .attr('cursor', 'pointer')
          .call(d3.drag()
            .on('start', (event, d) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on('drag', (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on('end', (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              if (!d.isSearched) {
                d.fx = null;
                d.fy = null;
              }
            }));

        // 枠線（円）
        node.append('circle')
          .attr('r', d => d.size / 2 + 3)
          .attr('fill', '#fff')
          .attr('stroke', d => d.color)
          .attr('stroke-width', d => d.isSearched ? 4 : 2);

        // 画像（clipPathで丸く切り抜き）
        node.each(function (d, i) {
          const clipId = `clip-${d.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
          defs.append('clipPath')
            .attr('id', clipId)
            .append('circle')
            .attr('r', d.size / 2);

          d3.select(this).append('image')
            .attr('xlink:href', d.imgUrl)
            .attr('x', -d.size / 2)
            .attr('y', -d.size / 2)
            .attr('width', d.size)
            .attr('height', d.size)
            .attr('clip-path', `url(#${clipId})`);
        });

        // ホバー時のハイライト＋ツールチップ
        node.on('mouseenter', function (event, d) {
          const isConnected = l => l.source.id === d.id || l.target.id === d.id;
          const connectedIds = new Set([d.id]);
          const connectedEdges = [];
          link.each(function (l) {
            if (isConnected(l)) {
              connectedIds.add(l.source.id);
              connectedIds.add(l.target.id);
              connectedEdges.push(l);
            }
          });

          link.transition().duration(200)
            .attr('stroke-opacity', l => isConnected(l) ? 1 : 0.1)
            .attr('stroke-width', l => isConnected(l) ? 3 : 1);
          node.select('circle').transition().duration(200).attr('opacity', n => connectedIds.has(n.id) ? 1 : 0.3);
          node.select('image').transition().duration(200).attr('opacity', n => connectedIds.has(n.id) ? 1 : 0.3);
          d3.select(this).raise().select('circle').transition().duration(150).attr('r', d.size / 2 + 6);

          // ツールチップ表示
          const types = [...new Set(connectedEdges.map(e => e.type))];
          showTooltip(event, `<strong>${d.id}</strong>${types.length ? `<br><span style="color:#aaa">${types.join(' / ')}</span>` : ''}`);
        })
          .on('mousemove', moveTooltip)
          .on('mouseleave', function (event, d) {
            link.transition().duration(200).attr('stroke-opacity', 0.6).attr('stroke-width', 2);
            node.select('circle').transition().duration(200).attr('opacity', 1);
            node.select('image').transition().duration(200).attr('opacity', 1);
            d3.select(this).select('circle').transition().duration(150).attr('r', d.size / 2 + 3);
            hideTooltip();
          })
          .on('click', (event, d) => {
            setInputAndUpdate(d.id);
          });

        // エッジのホバーでツールチップ表示
        link.on('mouseenter', function (event, d) {
          d3.select(this).raise().transition().duration(150).attr('stroke-opacity', 1).attr('stroke-width', 4);
          showTooltip(event, `<span style="color:${EDGE_COLORS[d.type] || '#888'}">${d.type}</span><br>${d.source.id} → ${d.target.id}`);
        })
          .on('mousemove', moveTooltip)
          .on('mouseleave', function () {
            d3.select(this).transition().duration(150).attr('stroke-opacity', 0.6).attr('stroke-width', 2);
            hideTooltip();
          });

        // シミュレーション更新
        simulation.on('tick', () => {
          // 曲線エッジ（ノード境界で終端）
          link.attr('d', d => {
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return '';

            // ターゲットノードの半径分だけ手前で終わる
            const targetRadius = nodeMap.get(d.target.id)?.size / 2 + 8 || 20;
            const ratio = (dist - targetRadius) / dist;
            const endX = d.source.x + dx * ratio;
            const endY = d.source.y + dy * ratio;

            const dr = dist * 0.8;
            return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${endX},${endY}`;
          });
          node.attr('transform', d => `translate(${d.x},${d.y})`);
        });
      }
    };

    const update = async () => {
      const input = inputChar.value.trim();
      const input2 = inputChar2.value.trim();

      variantsSection.hidden = true;
      candidatesSection.hidden = true;
      relatedSection.hidden = true;

      // 比較モードの処理
      if (compareMode) {
        if (!input && !input2) {
          return showEmpty('比較する文字を入力してください');
        }

        if (!input || !input2) {
          return showEmpty(input ? '比較する2つ目の文字を入力してください' : '比較する1つ目の文字を入力してください');
        }

        // 両方の文字を検索
        const { ucs: ucs1, ivs: ivs1 } = parseInput(input);
        const { ucs: ucs2, ivs: ivs2 } = parseInput(input2);
        const char1 = Array.from(input)[0] || '';
        const char2 = Array.from(input2)[0] || '';

        const [results1, results2] = await Promise.all([
          queryByUcs(ucs1, ivs1),
          queryByUcs(ucs2, ivs2)
        ]);

        if (results1.length === 0 || results2.length === 0) {
          const msg = results1.length === 0 && results2.length === 0
            ? '両方の文字がMJデータに見つかりません'
            : results1.length === 0
              ? `${char1} (${ucs1}) はMJデータに見つかりません`
              : `${char2} (${ucs2}) はMJデータに見つかりません`;
          return showEmpty(msg);
        }

        mainEmpty.hidden = true;
        variantsSection.hidden = false;
        renderCompareTable(results1, results2, char1, char2, ucs1, ivs1, ucs2, ivs2);
        const primary1 = results1.find((d) => isPrimaryResult(d, ucs1, ivs1, null)) || results1[0];
        const primary2 = results2.find((d) => isPrimaryResult(d, ucs2, ivs2, null)) || results2[0];
        addToHistory(char1, primary1?.['MJ文字図形名']);
        addToHistory(char2, primary2?.['MJ文字図形名']);
        trackSearch(`${char1} vs ${char2}`);
        return;
      }

      if (!input) {
        return showEmpty('文字を入力してください');
      }

      // MJ文字図形名での検索
      if (isMjName(input)) {
        const mjName = input.toUpperCase();
        const results = await queryByMjName(mjName);

        if (results.length === 0) {
          return showEmpty(`${mjName} はMJデータに見つかりません`);
        }

        mainEmpty.hidden = true;
        variantsSection.hidden = false;
        renderVariantsTable(results, null, null, null, mjName);
        await renderRelated(results, null, null, mjName);
        trackSearch(mjName);
        return;
      }

      // 読みでの検索
      if (isReading(input)) {
        const results = await queryByReading(input);

        if (results.length === 0) {
          return showEmpty(`「${input}」に該当する文字が見つかりません`);
        }

        mainEmpty.hidden = true;
        candidatesSection.hidden = false;
        renderCandidates(results, input);
        trackSearch(input);
        return;
      }

      // 文字での検索
      const { ucs, ivs } = parseInput(input);
      const chars = Array.from(input);
      const char = chars[0] || '';

      if (!char || !ucs) {
        return showEmpty('文字を入力してください');
      }

      const results = await queryByUcs(ucs, ivs);

      if (results.length === 0) {
        return showEmpty(`${char} (${ucs}) はMJデータに見つかりません`);
      }

      mainEmpty.hidden = true;
      variantsSection.hidden = false;
      renderVariantsTable(results, char, ucs, ivs);
      const primary = results.find((d) => isPrimaryResult(d, ucs, ivs, null)) || results[0];
      addToHistory(char, primary?.['MJ文字図形名']);
      await renderRelated(results, ucs, ivs, null);
      trackSearch(char);
    };

    const renderCompareTable = (results1, results2, char1, char2, ucs1, ivs1, ucs2, ivs2) => {
      clearTable();

      // IVSまたはUCSにマッチするバリアントを探す
      const findPrimary = (results, ucs, ivs) => {
        if (ivs) {
          const match = results.find(d => d['実装したMoji_JohoコレクションIVS'] === ivs);
          if (match) return match;
        }
        return results.find(d => d['実装したUCS'] === ucs) || results[0];
      };

      const data1 = findPrimary(results1, ucs1, ivs1);
      const data2 = findPrimary(results2, ucs2, ivs2);
      const headerRow = document.createElement('tr');
      headerRow.innerHTML = '<th>項目</th>';

      for (const [data, char] of [[data1, char1], [data2, char2]]) {
        const th = document.createElement('th');
        const mjName = data['MJ文字図形名'];
        th.innerHTML = createHeaderCellHtml(mjName, getMjImageUrl(mjName), getDisplayChar(data, char));
        headerRow.appendChild(th);
      }
      variantsHeader.appendChild(headerRow);

      for (const field of MJ_FIELDS) {
        const [val1, val2] = [formatValue(data1[field.key]), formatValue(data2[field.key])];
        const tr = document.createElement('tr');
        tr.innerHTML = `<th>${field.label}</th>`;

        for (const val of [val1, val2]) {
          const td = document.createElement('td');
          td.textContent = val;
          td.classList.add(val1 === val2 ? 'match' : 'diff');
          tr.appendChild(td);
        }
        variantsBody.appendChild(tr);
      }
    };

    const updateUrl = (char, char2 = null) => {
      const url = new URL(location.href);
      if (char) {
        url.searchParams.set('q', char);
      } else {
        url.searchParams.delete('q');
      }
      if (compareMode && char2) {
        url.searchParams.set('q2', char2);
      } else {
        url.searchParams.delete('q2');
      }
      history.replaceState(null, '', url);
    };

    const toggleCompareMode = () => {
      compareMode = compareToggle.checked;
      inputChar2.hidden = !compareMode;
      compareVs.hidden = !compareMode;
      if (!compareMode) {
        inputChar2.value = '';
        updateUrl(inputChar.value, null);
      }
      update();
    };

    compareToggle.addEventListener('change', toggleCompareMode);

    const getUrlValue = (input) => {
      const { ivs } = parseInput(input);
      const chars = Array.from(input);
      return ivs ? chars.slice(0, 2).join('') : (chars[0] || '');
    };

    const handleInput = () => {
      updateUrl(getUrlValue(inputChar.value), getUrlValue(inputChar2.value));
      update();
    };

    inputChar.addEventListener('input', handleInput);
    inputChar2.addEventListener('input', handleInput);

    const dbStatus = document.getElementById('db-status');

    renderHistory();

    Promise.all([initDuckDB(), initShrinkMap()])
      .then(() => {
        dbStatus.removeAttribute('aria-busy');
        dbStatus.textContent = 'MJ文字情報（約6万文字）と縮退マップを読み込みました';

        const params = new URLSearchParams(location.search);
        const q = params.get('q');
        const q2 = params.get('q2');
        if (q) {
          inputChar.value = q;
        }
        if (q2) {
          inputChar2.value = q2;
          compareToggle.checked = true;
          compareMode = true;
          inputChar2.hidden = false;
          compareVs.hidden = false;
        }
        update();
      })
      .catch((err) => {
        console.error('Init failed:', err);
        dbStatus.removeAttribute('aria-busy');
        dbStatus.textContent = 'データの読み込みに失敗しました: ' + err.message;
      });
  </script>
</body>

</html>