<!doctype html>
<html lang="ja" data-theme="light">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>文字情報基盤比較システム</title>
  <!-- __GA_SCRIPT__ -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <style>
    /* === Layout === */
    header { margin-bottom: var(--pico-block-spacing-vertical); }
    footer {
      margin-top: calc(var(--pico-block-spacing-vertical) * 2);
      padding-top: var(--pico-spacing);
      border-top: 1px solid var(--pico-muted-border-color);
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--pico-spacing);
    }
    .header-row h1 { margin-bottom: 0; }

    .compare-inputs {
      display: flex;
      gap: var(--pico-spacing);
      align-items: center;
      margin-bottom: var(--pico-block-spacing-vertical);
    }
    .compare-inputs input[type="search"] {
      font-family: "IPAmjMincho", "IPAmj明朝", serif;
      font-size: 1.5rem;
      max-width: 18rem;
      margin-bottom: 0;
    }

    /* === Sections === */
    .history-section,
    .candidates-section,
    .related-section { margin-bottom: var(--pico-block-spacing-vertical); }

    .history-header {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .history-reset-btn {
      background: transparent;
      border: none;
      color: var(--pico-muted-color);
      cursor: pointer;
      padding: 0;
      display: flex;
    }
    .history-reset-btn:hover { color: var(--pico-del-color); }

    .related-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }
    .hop-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--pico-muted-color);
      margin: 0;
    }
    .hop-input { width: 240px; margin: 0; padding: 0; }
    .hop-value { min-width: 1rem; }

    /* === Table === */
    .compare-table { font-size: 0.875rem; }
    .compare-table th:first-child {
      text-align: left;
      font-weight: normal;
      color: var(--pico-muted-color);
      min-width: 140px;
      position: sticky;
      left: 0;
      background: var(--pico-card-background-color);
    }
    .compare-table th:not(:first-child) { text-align: center; min-width: 100px; }
    .compare-table thead th { vertical-align: bottom; }
    .compare-table td { font-family: monospace; text-align: center; }
    .compare-table td.match { background: color-mix(in srgb, var(--pico-ins-color) 10%, transparent); }
    .compare-table td.diff { background: color-mix(in srgb, var(--pico-del-color) 10%, transparent); }

    /* === Components === */
    .mj-img {
      background: white;
      border-radius: var(--pico-border-radius);
      padding: 0.25rem;
    }
    .mj-img-primary {
      outline: 3px solid var(--pico-primary);
      outline-offset: 2px;
      box-shadow: 0 0 8px var(--pico-primary);
    }

    .copy-btn {
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      margin-top: 0.25rem;
      border: 1px solid var(--pico-muted-border-color);
      border-radius: var(--pico-border-radius);
      background: transparent;
      color: var(--pico-muted-color);
      cursor: pointer;
    }
    .copy-btn:hover { border-color: var(--pico-primary); color: var(--pico-primary); }
    .copy-btn.copied { border-color: var(--pico-ins-color); color: var(--pico-ins-color); }

    .char-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .char-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      border: 1px solid var(--pico-muted-border-color);
      border-radius: var(--pico-border-radius);
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      min-width: 4rem;
    }
    .char-item:hover {
      border-color: var(--pico-primary);
      background: color-mix(in srgb, var(--pico-primary) 5%, transparent);
    }
    .char-item.small { min-width: 2.5rem; width: 2.5rem; height: 2.5rem; justify-content: center; }
    .char-item .char { font-size: 1.5rem; }
    .char-item.small .char { font-size: 1.25rem; }

    .compare-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: var(--pico-muted-color);
      cursor: pointer;
      margin-bottom: 0;
    }
    .compare-toggle input[type="checkbox"] { margin: 0; }

    .compare-vs { font-size: 1.25rem; color: var(--pico-muted-color); }
    .clickable-ucs { cursor: pointer; color: var(--pico-primary); text-decoration: underline; }
    #main-empty { color: var(--pico-muted-color); font-style: italic; }

    /* === Network Graph === */
    .network-graph {
      margin-top: 0.5rem;
      width: 100%;
      border-radius: var(--pico-border-radius);
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    }
    .network-tooltip {
      position: fixed;
      padding: 0.4rem 0.6rem;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 4px;
      font-size: 0.7rem;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
    }
    .network-resize-handle {
      height: 8px;
      cursor: ns-resize;
      background: linear-gradient(to bottom, transparent, var(--pico-muted-border-color) 50%, transparent);
      border-radius: 0 0 var(--pico-border-radius) var(--pico-border-radius);
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0.5;
      transition: opacity 0.2s;
    }
    .network-resize-handle:hover { opacity: 1; }
    .network-resize-handle::after {
      content: '';
      width: 40px;
      height: 4px;
      background: var(--pico-muted-color);
      border-radius: 2px;
    }
  </style>
</head>

<body>
  <main class="container">
    <header>
      <div class="header-row">
        <h1>文字情報基盤比較システム</h1>
        <label class="compare-toggle">
          <input type="checkbox" id="compare-toggle" role="switch">
          比較モード
        </label>
      </div>
      <p id="db-status" aria-busy="true">MJ文字情報を読み込み中...</p>
    </header>

    <div class="compare-inputs">
      <input type="search" id="input-char" maxlength="10" placeholder="文字 / MJ番号 / 読み" autofocus />
      <span id="compare-vs" class="compare-vs" hidden>vs</span>
      <input type="search" id="input-char2" maxlength="10" placeholder="比較する文字" hidden />
    </div>

    <section id="history-section" class="history-section" hidden>
      <div class="history-header">
        <small>最近の検索</small>
        <button id="history-reset" class="history-reset-btn" title="履歴をクリア">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18" /><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" />
          </svg>
        </button>
      </div>
      <ul class="char-list" id="history-list"></ul>
    </section>

    <section id="candidates-section" class="candidates-section" hidden>
      <small id="candidates-label">読み検索結果:</small>
      <ul class="char-list" id="candidates-list"></ul>
    </section>

    <section id="main-section">
      <p id="main-empty">文字を入力してください</p>
      <figure id="variants-section" hidden>
        <table class="compare-table">
          <thead id="variants-header"></thead>
          <tbody id="variants-body"></tbody>
        </table>
      </figure>
    </section>

    <section id="related-section" class="related-section" hidden>
      <div class="related-header">
        <small>関連する文字</small>
        <label class="hop-control">
          <span>深さ:</span>
          <input type="range" id="hop-depth" class="hop-input" min="1" max="18" value="3">
          <span id="hop-depth-value" class="hop-value">3</span>
        </label>
      </div>
      <div id="network-graph" class="network-graph"></div>
      <div id="network-resize-handle" class="network-resize-handle" title="ドラッグで高さを調整"></div>
    </section>
  </main>

  <footer class="container">
    <small>
      本ツールは<a href="https://moji.or.jp/mojikiban/mjlist/" target="_blank" rel="noopener">MJ文字情報一覧表 Ver.006.02</a>および<a
        href="https://moji.or.jp/mojikiban/map/" target="_blank" rel="noopener">MJ縮退マップ Ver.1.2.0</a>（IPA）を利用しています。
    </small>
    <!-- __GA_PRIVACY__ -->
  </footer>

  <script type="module">
    import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm';

    // ============================================================
    // Config & Constants
    // ============================================================
    const CONFIG = {
      historyKey: 'mj-viewer-history',
      maxHistory: 20,
      debounceMs: 400,
      queryLimit: 100,
      animation: { hopDelay: 150, trailDuration: 300 },
      colors: { primary: '#1976d2', related: '#9e9e9e' }
    };

    const SHRINK_FIELDS = [
      { key: 'JIS包摂規準・UCS統合規則', id: 'jis', label: 'JIS包摂', color: '#64b5f6' },
      { key: '辞書類等による関連字', id: 'dict', label: '辞書関連', color: '#81c784' },
      { key: '法務省告示582号別表第四', id: 'notice', label: '法務省告示', color: '#ffb74d' },
      { key: '法務省戸籍法関連通達・通知', id: 'koseki', label: '戸籍法通達', color: '#ce93d8' },
      { key: '読み・字形による類推', id: 'analog', label: '類推', color: '#f48fb1' }
    ];

    const EDGE_COLORS = Object.fromEntries(SHRINK_FIELDS.map(f => [f.id, f.color]));
    const EDGE_LABELS = Object.fromEntries(SHRINK_FIELDS.map(f => [f.id, f.label]));

    const MJ_FIELDS = [
      { key: 'MJ文字図形名', label: 'MJ文字図形名' },
      { key: '対応するUCS', label: '対応するUCS' },
      { key: 'UnicodeBlock', label: 'Unicodeブロック', computed: true },
      { key: '実装したUCS', label: '実装したUCS' },
      { key: '実装したMoji_JohoコレクションIVS', label: '実装したIVS' },
      { key: 'X0213', label: 'JIS X 0213' },
      { key: 'X0213_level', label: 'JIS X 0213 水準', computed: true },
      { key: 'X0213 包摂区分', label: 'JIS X 0213 包摂区分' },
      { key: 'X0213 包摂連番', label: 'JIS X 0213 包摂連番' },
      { key: 'X0212', label: 'JIS X 0212' },
      { key: '戸籍統一文字番号', label: '戸籍統一文字番号' },
      { key: '住基ネット統一文字コード', label: '住基ネット統一文字コード' },
      { key: '入管正字コード', label: '入管正字コード' },
      { key: '漢字施策', label: '漢字施策' },
      { key: '対応する互換漢字', label: '対応する互換漢字' },
      { key: '総画数(参考)', label: '総画数' },
      { key: '部首1(参考)', label: '部首' },
      { key: '内画数1(参考)', label: '内画数' },
      { key: '読み(参考)', label: '読み' },
    ];

    const ICONS = {
      copy: '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy',
      check: '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> Copied!'
    };

    // ============================================================
    // DOM Elements
    // ============================================================
    const $ = (id) => document.getElementById(id);
    const dom = {
      inputChar: $('input-char'),
      inputChar2: $('input-char2'),
      compareToggle: $('compare-toggle'),
      compareVs: $('compare-vs'),
      mainEmpty: $('main-empty'),
      variantsSection: $('variants-section'),
      variantsHeader: $('variants-header'),
      variantsBody: $('variants-body'),
      candidatesSection: $('candidates-section'),
      candidatesList: $('candidates-list'),
      candidatesLabel: $('candidates-label'),
      historySection: $('history-section'),
      historyList: $('history-list'),
      historyReset: $('history-reset'),
      relatedSection: $('related-section'),
      hopDepth: $('hop-depth'),
      hopDepthValue: $('hop-depth-value'),
      networkGraph: $('network-graph'),
      networkResizeHandle: $('network-resize-handle'),
      dbStatus: $('db-status')
    };

    // ============================================================
    // State
    // ============================================================
    let conn = null;
    let shrinkMap = null;
    let ucsToMjNames = null;
    let compareMode = false;
    let lastFocusedInput = dom.inputChar;
    let lastRelatedParams = null;
    let networkGraphHeight = null;

    // ============================================================
    // Utilities
    // ============================================================
    const debounce = (fn, ms) => {
      let timer;
      return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), ms); };
    };

    const escapeSql = (v) => String(v).replace(/'/g, "''");
    const quoteSql = (v) => `'${escapeSql(v)}'`;
    const buildInClause = (vals) => vals.map(quoteSql).join(', ');
    const formatValue = (v) => (v === '' || v == null) ? '-' : v;

    const ucsToChar = (ucs) => ucs ? String.fromCodePoint(parseInt(ucs.replace('U+', ''), 16)) : null;
    const ivsToChar = (ivs) => {
      if (!ivs) return null;
      const parts = ivs.includes('_')
        ? ivs.split('_').map(p => parseInt(p, 16))
        : ivs.split(' ').map(p => parseInt(p.replace('U+', ''), 16));
      return String.fromCodePoint(...parts);
    };

    const getDisplayChar = (data, fallback = '?') =>
      ivsToChar(data['実装したMoji_JohoコレクションIVS']) ||
      ucsToChar(data['実装したUCS'] || data['対応するUCS']) || fallback;

    const getMjImageUrl = (name) => name ? `https://moji.or.jp/mojikibansearch/img/MJ/${name}.png` : null;

    const isMjName = (s) => /^MJ\d{6}$/i.test(s.trim());
    const isReading = (s) => /^[\u3040-\u309F\u30A0-\u30FF]+$/.test(s.trim());

    const parseInput = (input) => {
      const chars = Array.from(input);
      if (!chars.length) return { ucs: null, ivs: null };
      const base = chars[0].codePointAt(0);
      const ucs = `U+${base.toString(16).toUpperCase().padStart(4, '0')}`;
      if (chars.length >= 2) {
        const vs = chars[1].codePointAt(0);
        if (vs >= 0xE0100 && vs <= 0xE01EF) {
          return { ucs, ivs: `${base.toString(16).toUpperCase()}_${vs.toString(16).toUpperCase()}` };
        }
      }
      return { ucs, ivs: null };
    };

    const getCharFromInput = (input) => {
      const { ivs } = parseInput(input);
      const chars = Array.from(input);
      return ivs ? chars.slice(0, 2).join('') : (chars[0] || '');
    };

    const calcJisLevel = (x0213) => {
      if (!x0213) return '';
      const m = x0213.match(/^(\d)-(\d+)-(\d+)$/);
      if (!m) return '';
      const [, men, ku] = m.map(Number);
      if (men === 1) {
        if (ku >= 1 && ku <= 8) return '非漢字';
        if (ku >= 16 && ku <= 47) return '1';
        if (ku >= 48 && ku <= 84) return '2';
        return '3';
      }
      return men === 2 ? '4' : '';
    };

    const getUnicodeBlock = (ucs) => {
      if (!ucs) return '';
      const code = parseInt(ucs.replace('U+', ''), 16);
      if (isNaN(code)) return '';
      const blocks = [
        [0x4E00, 0x9FFF, 'CJK統合漢字'], [0x3400, 0x4DBF, 'CJK統合漢字拡張A'],
        [0x20000, 0x2A6DF, 'CJK統合漢字拡張B'], [0x2A700, 0x2B73F, 'CJK統合漢字拡張C'],
        [0x2B740, 0x2B81F, 'CJK統合漢字拡張D'], [0x2B820, 0x2CEAF, 'CJK統合漢字拡張E'],
        [0x2CEB0, 0x2EBEF, 'CJK統合漢字拡張F'], [0x30000, 0x3134F, 'CJK統合漢字拡張G'],
        [0x31350, 0x323AF, 'CJK統合漢字拡張H'], [0xF900, 0xFAFF, 'CJK互換漢字'],
        [0x2F800, 0x2FA1F, 'CJK互換漢字補助'], [0x2F00, 0x2FDF, '康煕部首'],
        [0x2E80, 0x2EFF, 'CJK部首補助'], [0x3000, 0x303F, 'CJK記号・句読点']
      ];
      return blocks.find(([min, max]) => code >= min && code <= max)?.[2] || '';
    };

    const isPrimaryResult = (data, inputUcs, inputIvs, inputMjName) =>
      inputMjName ? data['MJ文字図形名'] === inputMjName
        : inputIvs ? data['実装したMoji_JohoコレクションIVS'] === inputIvs
          : data['実装したUCS'] === inputUcs;

    const trackSearch = (term) => {
      if (typeof gtag !== 'undefined') gtag('event', 'search', { search_term: term });
    };

    // ============================================================
    // Tooltip
    // ============================================================
    const tooltip = (() => {
      let el = null;
      const getEl = () => {
        if (!el) {
          el = document.createElement('div');
          el.className = 'network-tooltip';
          el.style.display = 'none';
          document.body.appendChild(el);
        }
        return el;
      };
      const setPos = (e) => { const t = getEl(); t.style.left = `${e.clientX + 12}px`; t.style.top = `${e.clientY - 10}px`; };
      return {
        show: (e, html) => { const t = getEl(); t.innerHTML = html; t.style.display = 'block'; setPos(e); },
        move: setPos,
        hide: () => { if (el) el.style.display = 'none'; }
      };
    })();

    // ============================================================
    // Database
    // ============================================================
    const SQL_COLUMNS = MJ_FIELDS.filter(f => !f.computed).map(f => `"${f.key}"`).join(', ');

    const mapQueryResult = (result) => result.toArray().map(row => {
      const data = {};
      MJ_FIELDS.filter(f => !f.computed).forEach(f => data[f.key] = row[f.key]);
      data.font = row.font;
      data['X0213_level'] = calcJisLevel(data['X0213']);
      data['UnicodeBlock'] = getUnicodeBlock(data['対応するUCS']);
      return data;
    });

    const runMjiQuery = async ({ where, distinct = false, limit = null }) => {
      if (!conn || !where) return [];
      const sql = `SELECT ${distinct ? 'DISTINCT ' : ''}${SQL_COLUMNS}, font FROM mji WHERE ${where}${limit ? ` LIMIT ${limit}` : ''}`;
      return mapQueryResult(await conn.query(sql));
    };

    const initDuckDB = async () => {
      const bundle = await duckdb.selectBundle(duckdb.getJsDelivrBundles());
      const workerUrl = URL.createObjectURL(new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' }));
      const db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), new Worker(workerUrl));
      await db.instantiate(bundle.mainModule);
      URL.revokeObjectURL(workerUrl);
      conn = await db.connect();
      const csv = await (await fetch('mji.00602.csv')).arrayBuffer();
      await db.registerFileBuffer('mji.csv', new Uint8Array(csv));
      await conn.query(`CREATE TABLE mji AS SELECT * FROM read_csv_auto('mji.csv')`);
    };

    const initShrinkMap = async () => {
      const data = await (await fetch('MJShrinkMapVer.1.2.0/MJShrinkMap.1.2.0.json')).json();
      shrinkMap = new Map(data.content.map(e => [e.MJ文字図形名, e]));
      ucsToMjNames = new Map();
      for (const entry of data.content) {
        const mjName = entry.MJ文字図形名;
        for (const { key } of SHRINK_FIELDS) {
          for (const item of entry[key] || []) {
            if (item.UCS) {
              if (!ucsToMjNames.has(item.UCS)) ucsToMjNames.set(item.UCS, []);
              if (!ucsToMjNames.get(item.UCS).includes(mjName)) ucsToMjNames.get(item.UCS).push(mjName);
            }
          }
        }
      }
    };

    // ============================================================
    // Queries
    // ============================================================
    const queryByUcs = (ucs, ivs = null) => {
      if (!ucs) return Promise.resolve([]);
      const ivsCondition = ivs ? ` OR "実装したMoji_JohoコレクションIVS" = ${quoteSql(ivs)}` : '';
      const q = quoteSql(ucs);
      return runMjiQuery({
        where: `"対応するUCS" IN (SELECT "対応するUCS" FROM mji WHERE "対応するUCS" = ${q} OR "実装したUCS" = ${q}${ivsCondition})`
      });
    };

    const queryByMjName = (name) => runMjiQuery({
      where: `"対応するUCS" IN (SELECT "対応するUCS" FROM mji WHERE "MJ文字図形名" = ${quoteSql(name)})`
    });

    const queryByReading = (reading) => {
      const hira = reading.replace(/[\u30A0-\u30FF]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0x60));
      const kata = reading.replace(/[\u3040-\u309F]/g, ch => String.fromCharCode(ch.charCodeAt(0) + 0x60));
      const [h, k] = [escapeSql(hira), escapeSql(kata)];
      return runMjiQuery({
        distinct: true, limit: CONFIG.queryLimit,
        where: `"読み(参考)" LIKE '${h}%' OR "読み(参考)" LIKE '${k}%' OR "読み(参考)" LIKE '%・${h}%' OR "読み(参考)" LIKE '%・${k}%'`
      });
    };

    const queryAllByUcsList = (list) => list.length ? runMjiQuery({ where: `"対応するUCS" IN (${buildInClause(list)})` }) : [];
    const queryAllByMjNames = (list) => list.length ? runMjiQuery({ where: `"MJ文字図形名" IN (${buildInClause(list)})` }) : [];

    // ============================================================
    // Shrink Map Helpers
    // ============================================================
    const getRelatedUcs = (mjName) => {
      const entry = shrinkMap?.get(mjName);
      if (!entry) return [];
      const set = new Set();
      SHRINK_FIELDS.forEach(({ key }) => (entry[key] || []).forEach(item => item.UCS && set.add(item.UCS)));
      return [...set];
    };

    const collectRelatedMjNames = (startMjNames, maxDepth) => {
      const mjHops = new Map(), mjParent = new Map(), allUcs = new Set();
      const queue = startMjNames.map(mj => ({ mj, hop: 0, parent: null }));
      while (queue.length) {
        const { mj, hop, parent } = queue.shift();
        if (mjHops.has(mj) || hop >= maxDepth) continue;
        mjHops.set(mj, hop);
        mjParent.set(mj, parent);
        for (const ucs of getRelatedUcs(mj)) {
          allUcs.add(ucs);
          (ucsToMjNames?.get(ucs) || []).forEach(other => {
            if (!mjHops.has(other)) queue.push({ mj: other, hop: hop + 1, parent: mj });
          });
        }
      }
      return { mjNames: [...mjHops.keys()], mjHops, mjParent, relatedUcs: [...allUcs] };
    };

    const collectRelatedEdges = (mjNames) => {
      const edges = [], ucsSet = new Set();
      mjNames.forEach(mjName => {
        const entry = shrinkMap?.get(mjName);
        if (!entry) return;
        SHRINK_FIELDS.forEach(({ key, id }) => {
          (entry[key] || []).forEach(item => {
            if (item.UCS) { ucsSet.add(item.UCS); edges.push({ from: mjName, to: item.UCS, type: id }); }
          });
        });
      });
      return { edges, ucsNodes: [...ucsSet] };
    };

    // ============================================================
    // History
    // ============================================================
    const getHistory = () => {
      try {
        return (JSON.parse(localStorage.getItem(CONFIG.historyKey)) || [])
          .map(item => typeof item === 'string' ? { char: item, mjName: null } : item);
      } catch { return []; }
    };

    const addToHistory = (char, mjName = null) => {
      if (!char || isMjName(char) || isReading(char)) return;
      const history = getHistory().filter(i => !(i.char === char && i.mjName === mjName));
      history.unshift({ char, mjName });
      if (history.length > CONFIG.maxHistory) history.pop();
      localStorage.setItem(CONFIG.historyKey, JSON.stringify(history));
      renderHistory();
    };

    const renderHistory = () => {
      const history = getHistory();
      dom.historySection.hidden = !history.length;
      dom.historyList.textContent = '';
      history.forEach(({ char, mjName }) => {
        dom.historyList.appendChild(createCharItem(char, mjName, { small: true, onClick: () => setInputAndUpdate(char) }));
      });
    };

    // ============================================================
    // UI Components
    // ============================================================
    const createCharItem = (char, mjName, { small, showLabel, onClick } = {}) => {
      const li = document.createElement('li');
      li.className = `char-item${small ? ' small' : ''}`;
      li.title = char;
      const imgUrl = getMjImageUrl(mjName);
      const label = showLabel ? `<small style="font-size:0.6rem;color:var(--pico-muted-color)">${mjName}</small>` : '';
      li.innerHTML = imgUrl
        ? `<img src="${imgUrl}" alt="${mjName}" class="mj-img" style="height:${small ? '1.5' : '2'}rem">${label}`
        : `<span class="char">${char}</span>${label}`;
      if (onClick) li.addEventListener('click', onClick);
      return li;
    };

    const copyToClipboard = async (text, btn) => {
      try {
        await navigator.clipboard.writeText(text);
        btn.innerHTML = ICONS.check;
        btn.classList.add('copied');
        setTimeout(() => { btn.innerHTML = ICONS.copy; btn.classList.remove('copied'); }, 1500);
      } catch (e) { console.error('Copy failed:', e); }
    };

    const getCopyChar = (data, fallback) => {
      const ivs = data['実装したMoji_JohoコレクションIVS'];
      if (ivs) {
        const [base, vs] = ivs.split('_');
        return String.fromCodePoint(parseInt(base, 16), parseInt(vs, 16));
      }
      return getDisplayChar(data, fallback);
    };

    const createClickableUcs = (value) => {
      const span = document.createElement('span');
      span.className = 'clickable-ucs';
      span.textContent = value;
      span.addEventListener('click', () => setInputAndUpdate(ucsToChar(value)));
      return span;
    };

    // ============================================================
    // Table Rendering
    // ============================================================
    const clearTable = () => { dom.variantsHeader.textContent = ''; dom.variantsBody.textContent = ''; };

    const createHeaderRow = (columns) => {
      const tr = document.createElement('tr');
      tr.innerHTML = '<th>項目</th>';
      columns.forEach(col => {
        const th = document.createElement('th');
        const imgClass = col.isPrimary ? 'mj-img mj-img-primary' : 'mj-img';
        th.innerHTML = col.imgUrl
          ? `<img src="${col.imgUrl}" alt="${col.mjName}" class="${imgClass}" style="height:2.5rem;vertical-align:middle;"><div style="font-size:0.7rem">${col.mjName}</div>`
          : `<div style="font-size:1.5rem">${col.displayChar}</div><div style="font-size:0.7rem">${col.mjName || ''}</div>`;
        if (col.onClick) { th.style.cursor = 'pointer'; th.addEventListener('click', col.onClick); }
        if (col.copyText) {
          const btn = document.createElement('button');
          btn.className = 'copy-btn';
          btn.innerHTML = ICONS.copy;
          btn.addEventListener('click', (e) => { e.stopPropagation(); copyToClipboard(col.copyText, btn); });
          th.appendChild(btn);
        }
        tr.appendChild(th);
      });
      return tr;
    };

    const appendValueCell = (tr, value, { clickable, matchClass } = {}) => {
      const td = document.createElement('td');
      clickable ? td.appendChild(createClickableUcs(value)) : td.textContent = value;
      if (matchClass) td.classList.add(matchClass);
      tr.appendChild(td);
    };

    const renderVariantsTable = (results, char, inputUcs, inputIvs = null, inputMjName = null) => {
      clearTable();
      const columns = results.map(data => {
        const mjName = data['MJ文字図形名'], displayChar = getDisplayChar(data, char);
        return {
          mjName, displayChar, imgUrl: getMjImageUrl(mjName),
          isPrimary: isPrimaryResult(data, inputUcs, inputIvs, inputMjName),
          copyText: getCopyChar(data, char),
          onClick: (e) => { if (!e.target.closest('.copy-btn')) setInputAndUpdate(displayChar); }
        };
      });
      dom.variantsHeader.appendChild(createHeaderRow(columns));

      const primaryIdx = results.findIndex(d => isPrimaryResult(d, inputUcs, inputIvs, inputMjName));
      const clickableFields = ['対応する互換漢字', '対応するUCS', '実装したUCS'];

      MJ_FIELDS.forEach(field => {
        const values = results.map(d => formatValue(d[field.key]));
        const tr = document.createElement('tr');
        tr.innerHTML = `<th>${field.label}</th>`;
        const primaryVal = primaryIdx >= 0 ? values[primaryIdx] : null;
        values.forEach(v => {
          const clickable = clickableFields.includes(field.key) && v !== '-' && v.startsWith('U+');
          const matchClass = results.length > 1 && primaryVal !== null ? (v === primaryVal ? 'match' : 'diff') : null;
          appendValueCell(tr, v, { clickable, matchClass });
        });
        dom.variantsBody.appendChild(tr);
      });
    };

    const renderCompareTable = (results1, results2, char1, char2, ucs1, ivs1, ucs2, ivs2) => {
      clearTable();
      const findPrimary = (results, ucs, ivs) =>
        (ivs && results.find(d => d['実装したMoji_JohoコレクションIVS'] === ivs)) ||
        results.find(d => d['実装したUCS'] === ucs) || results[0];

      const [data1, data2] = [findPrimary(results1, ucs1, ivs1), findPrimary(results2, ucs2, ivs2)];
      const columns = [[data1, char1], [data2, char2]].map(([data, char]) => ({
        mjName: data['MJ文字図形名'],
        displayChar: getDisplayChar(data, char),
        imgUrl: getMjImageUrl(data['MJ文字図形名']),
        onClick: () => setInputAndUpdate(getDisplayChar(data, char))
      }));
      dom.variantsHeader.appendChild(createHeaderRow(columns));

      MJ_FIELDS.forEach(field => {
        const [v1, v2] = [formatValue(data1[field.key]), formatValue(data2[field.key])];
        const tr = document.createElement('tr');
        tr.innerHTML = `<th>${field.label}</th>`;
        const matchClass = v1 === v2 ? 'match' : 'diff';
        appendValueCell(tr, v1, { matchClass });
        appendValueCell(tr, v2, { matchClass });
        dom.variantsBody.appendChild(tr);
      });
    };

    const renderCandidates = (results, reading) => {
      dom.candidatesList.textContent = '';
      dom.candidatesLabel.textContent = `「${reading}」の検索結果 (${results.length}件):`;
      results.forEach(data => {
        const displayChar = getDisplayChar(data);
        dom.candidatesList.appendChild(createCharItem(displayChar, data['MJ文字図形名'], {
          showLabel: true, onClick: () => setInputAndUpdate(displayChar)
        }));
      });
    };

    // ============================================================
    // Network Graph
    // ============================================================
    const renderRelated = async (results, inputUcs, inputIvs, inputMjName) => {
      lastRelatedParams = { results, inputUcs, inputIvs, inputMjName };

      const currentMjNames = results.map(d => d['MJ文字図形名']).filter(Boolean);
      const hopDepth = parseInt(dom.hopDepth.value, 10) || 3;
      const { mjNames: relatedMjNames, mjHops, mjParent, relatedUcs } = collectRelatedMjNames(currentMjNames, hopDepth);
      const allUcs = [...new Set([...results.map(d => d['対応するUCS']).filter(Boolean), ...relatedUcs])];

      const hasRelated = relatedMjNames.length || allUcs.length;
      dom.relatedSection.hidden = !hasRelated;
      if (!hasRelated) return;

      const [mjResults, ucsResults] = await Promise.all([
        queryAllByMjNames([...new Set([...currentMjNames, ...relatedMjNames])]),
        queryAllByUcsList(allUcs)
      ]);
      const allResults = [...new Map([...mjResults, ...ucsResults].map(r => [r['MJ文字図形名'], r])).values()];
      if (!allResults.length || typeof d3 === 'undefined') return;

      const { edges: shrinkEdges } = collectRelatedEdges(allResults.map(r => r['MJ文字図形名']));
      const ucsToMjMap = new Map();
      allResults.forEach(r => {
        const ucs = r['対応するUCS'];
        if (!ucsToMjMap.has(ucs)) ucsToMjMap.set(ucs, []);
        ucsToMjMap.get(ucs).push(r);
      });

      const primaryResult = results.find(d => isPrimaryResult(d, inputUcs, inputIvs, inputMjName));
      const searchedMjSet = new Set(primaryResult ? [primaryResult['MJ文字図形名']] : []);

      // Create nodes
      const nodes = [], nodeMap = new Map();
      for (const [ucs, mjList] of ucsToMjMap) {
        for (const mj of mjList) {
          const mjName = mj['MJ文字図形名'], isSearched = searchedMjSet.has(mjName);
          const node = {
            id: mjName, ucs, ivs: mj['実装したMoji_JohoコレクションIVS'],
            displayChar: ivsToChar(mj['実装したMoji_JohoコレクションIVS']) || ucsToChar(mj['実装したUCS'] || ucs),
            imgUrl: getMjImageUrl(mjName), isSearched,
            hop: mjHops.get(mjName) ?? 0, parent: mjParent.get(mjName) ?? null,
            color: isSearched ? CONFIG.colors.primary : CONFIG.colors.related,
            size: isSearched ? 48 : 32
          };
          nodes.push(node);
          nodeMap.set(mjName, node);
        }
      }

      // Create links
      const links = [], seen = new Set();
      shrinkEdges.forEach(({ from, to: toUcs, type }) => {
        (ucsToMjMap.get(toUcs) || []).forEach(toData => {
          const toMj = toData['MJ文字図形名'];
          if (from === toMj || !nodeMap.has(from) || !nodeMap.has(toMj)) return;
          const key = `${from}->${toMj}-${type}`;
          if (seen.has(key)) return;
          seen.add(key);
          links.push({
            source: nodeMap.get(from), target: nodeMap.get(toMj), type,
            color: EDGE_COLORS[type] || '#999',
            hop: Math.max(nodeMap.get(from)?.hop ?? 0, nodeMap.get(toMj)?.hop ?? 0)
          });
        });
      });

      // Setup SVG
      dom.networkGraph.innerHTML = '';
      const width = dom.networkGraph.clientWidth;
      const height = networkGraphHeight || Math.round(window.innerHeight * 0.5);
      dom.networkGraph.style.height = `${height}px`;
      const [centerX, centerY] = [width / 2, height / 2];

      const svg = d3.select(dom.networkGraph).append('svg')
        .attr('width', width).attr('height', height).attr('viewBox', [0, 0, width, height]);
      const g = svg.append('g');
      svg.call(d3.zoom().scaleExtent([0.3, 3]).on('zoom', e => g.attr('transform', e.transform)));

      // Arrow markers
      const defs = svg.append('defs');
      Object.entries(EDGE_COLORS).forEach(([type, color]) => {
        defs.append('marker').attr('id', `arrow-${type}`).attr('viewBox', '0 -5 10 10')
          .attr('refX', 12).attr('refY', 0).attr('markerWidth', 5).attr('markerHeight', 5).attr('orient', 'auto')
          .append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', color);
      });

      // Layout nodes in concentric circles
      const hopRadius = 100, hopGroups = new Map();
      nodes.forEach(n => { if (!hopGroups.has(n.hop)) hopGroups.set(n.hop, []); hopGroups.get(n.hop).push(n); });
      hopGroups.forEach((group, hop) => {
        const radius = hop * hopRadius, step = (2 * Math.PI) / group.length;
        group.forEach((n, i) => {
          const angle = step * i - Math.PI / 2;
          n.x = centerX + radius * Math.cos(angle);
          n.y = centerY + radius * Math.sin(angle);
          if (n.isSearched) { n.fx = centerX; n.fy = centerY; }
        });
      });

      // Simulation
      const simulation = d3.forceSimulation(nodes).force('collision', d3.forceCollide().radius(d => d.size + 5)).stop();
      for (let i = 0; i < 50; i++) simulation.tick();

      const { hopDelay, trailDuration } = CONFIG.animation;

      // Draw links
      const link = g.append('g').attr('class', 'links').selectAll('path').data(links).join('path')
        .attr('stroke', d => d.color).attr('stroke-width', 1).attr('stroke-opacity', 0)
        .attr('fill', 'none').attr('marker-end', d => `url(#arrow-${d.type})`).attr('stroke-dasharray', '5,3');

      const trailLayer = g.append('g').attr('class', 'trails');

      // Draw nodes
      const node = g.append('g').attr('class', 'nodes').selectAll('g').data(nodes).join('g')
        .attr('cursor', 'pointer').attr('opacity', d => d.isSearched ? 1 : 0)
        .attr('transform', d => `translate(${d.x},${d.y})`)
        .call(d3.drag().clickDistance(5)
          .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
          .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
          .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); if (!d.isSearched) { d.fx = null; d.fy = null; } }));

      node.append('circle').attr('r', d => d.size / 2 + 3).attr('fill', '#fff')
        .attr('stroke', d => d.color).attr('stroke-width', d => d.isSearched ? 4 : 2);

      // Node images with fallback
      node.each(function(d) {
        const clipId = `clip-${d.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
        defs.append('clipPath').attr('id', clipId).append('circle').attr('r', d.size / 2);
        const nodeEl = d3.select(this), img = new Image();
        img.onload = () => nodeEl.append('image').attr('xlink:href', d.imgUrl)
          .attr('x', -d.size / 2).attr('y', -d.size / 2).attr('width', d.size).attr('height', d.size)
          .attr('clip-path', `url(#${clipId})`);
        img.onerror = () => nodeEl.append('text').attr('text-anchor', 'middle').attr('dominant-baseline', 'central')
          .attr('font-size', d.size * 0.6).attr('fill', '#333').text(d.displayChar || '?');
        img.src = d.imgUrl;
      });

      // Trail animation
      const maxHop = Math.max(...nodes.map(n => n.hop), 0);
      nodes.forEach((n, idx) => {
        if (n.isSearched) return;
        const delay = n.hop * hopDelay;
        const parentNode = n.parent ? nodeMap.get(n.parent) : null;
        const [startX, startY] = parentNode ? [parentNode.x, parentNode.y] : [centerX, centerY];

        const gradId = `trail-grad-${idx}`;
        const grad = defs.append('linearGradient').attr('id', gradId).attr('gradientUnits', 'userSpaceOnUse')
          .attr('x1', startX).attr('y1', startY).attr('x2', startX).attr('y2', startY);
        grad.append('stop').attr('offset', '0%').attr('stop-color', n.color).attr('stop-opacity', 0);
        grad.append('stop').attr('offset', '50%').attr('stop-color', n.color).attr('stop-opacity', 0.4);
        grad.append('stop').attr('offset', '100%').attr('stop-color', '#fff').attr('stop-opacity', 1);

        const trail = trailLayer.append('line')
          .attr('x1', startX).attr('y1', startY).attr('x2', startX).attr('y2', startY)
          .attr('stroke', `url(#${gradId})`).attr('stroke-width', 4).attr('stroke-linecap', 'round');

        trail.transition().delay(delay).duration(trailDuration)
          .attrTween('x2', () => d3.interpolate(startX, n.x))
          .attrTween('y2', () => d3.interpolate(startY, n.y))
          .on('start', function() {
            d3.select(this).attr('stroke-opacity', 1);
            grad.transition().duration(trailDuration).attr('x2', n.x).attr('y2', n.y);
          })
          .transition().duration(150).attr('stroke-opacity', 0)
          .on('end', () => { trail.remove(); grad.remove(); });

        node.filter(d => d.id === n.id).transition().delay(delay + trailDuration * 0.8).duration(150).attr('opacity', 1);
      });

      link.transition().delay(d => d.hop * hopDelay + trailDuration).duration(300).attr('stroke-opacity', 0.6);
      setTimeout(() => simulation.alpha(0).restart(), maxHop * hopDelay + trailDuration + 300);

      // Hover handlers
      const highlightConnections = (d, highlight) => {
        const isConn = l => l.source.id === d.id || l.target.id === d.id;
        const connIds = new Set([d.id]);
        const connEdges = [];
        link.each(l => { if (isConn(l)) { connIds.add(l.source.id); connIds.add(l.target.id); connEdges.push(l); } });

        if (highlight) {
          link.transition().duration(200).attr('stroke-opacity', l => isConn(l) ? 1 : 0.1).attr('stroke-width', l => isConn(l) ? 2 : 0.5);
          node.transition().duration(200).attr('opacity', n => connIds.has(n.id) ? 1 : 0.3);
        } else {
          link.transition().duration(200).attr('stroke-opacity', 0.6).attr('stroke-width', 1);
          node.transition().duration(200).attr('opacity', 1);
        }
        return connEdges;
      };

      node.on('mouseenter', function(e, d) {
        const edges = highlightConnections(d, true);
        d3.select(this).raise().select('circle').transition().duration(150).attr('r', d.size / 2 + 6);
        const types = [...new Set(edges.map(ed => EDGE_LABELS[ed.type] || ed.type))];
        tooltip.show(e, `<strong>${d.id}</strong>${types.length ? `<br><span style="color:#aaa">${types.join(' / ')}</span>` : ''}`);
      })
        .on('mousemove', tooltip.move)
        .on('mouseleave', function(e, d) {
          highlightConnections(d, false);
          d3.select(this).select('circle').transition().duration(150).attr('r', d.size / 2 + 3);
          tooltip.hide();
        })
        .on('click', (e, d) => setInputAndUpdate(d.displayChar || d.id));

      link.on('mouseenter', function(e, d) {
        d3.select(this).raise().transition().duration(150).attr('stroke-opacity', 1).attr('stroke-width', 2);
        tooltip.show(e, `<span style="color:${EDGE_COLORS[d.type] || '#888'}">${EDGE_LABELS[d.type] || d.type}</span><br>${d.source.id} → ${d.target.id}`);
      })
        .on('mousemove', tooltip.move)
        .on('mouseleave', function() {
          d3.select(this).transition().duration(150).attr('stroke-opacity', 0.6).attr('stroke-width', 1);
          tooltip.hide();
        });

      // Update positions
      const updatePositions = () => {
        link.attr('d', d => {
          const dx = d.target.x - d.source.x, dy = d.target.y - d.source.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (!dist) return '';
          const targetR = (nodeMap.get(d.target.id)?.size / 2 + 8) || 20;
          const ratio = (dist - targetR) / dist;
          return `M${d.source.x},${d.source.y}A${dist * 0.8},${dist * 0.8} 0 0,1 ${d.source.x + dx * ratio},${d.source.y + dy * ratio}`;
        });
        node.attr('transform', d => `translate(${d.x},${d.y})`);
      };
      updatePositions();
      simulation.on('tick', updatePositions);
    };

    // ============================================================
    // Main Logic
    // ============================================================
    const getTargetInput = () => compareMode && lastFocusedInput === dom.inputChar2 ? dom.inputChar2 : dom.inputChar;

    const showEmpty = (msg) => { dom.mainEmpty.hidden = false; dom.mainEmpty.textContent = msg; };

    const resetSections = () => {
      dom.variantsSection.hidden = true;
      dom.candidatesSection.hidden = true;
      dom.relatedSection.hidden = true;
    };

    const setInputAndUpdate = (value) => {
      getTargetInput().value = value;
      updateUrl(dom.inputChar.value, dom.inputChar2.value);
      update();
    };

    const updateUrl = (char, char2) => {
      const url = new URL(location.href);
      char ? url.searchParams.set('q', char) : url.searchParams.delete('q');
      compareMode && char2 ? url.searchParams.set('q2', char2) : url.searchParams.delete('q2');
      history.replaceState(null, '', url);
    };

    const update = async () => {
      const [input, input2] = [dom.inputChar.value.trim(), dom.inputChar2.value.trim()];
      resetSections();

      // Compare mode
      if (compareMode) {
        if (!input && !input2) return showEmpty('比較する文字を入力してください');
        if (!input || !input2) return showEmpty(input ? '比較する2つ目の文字を入力してください' : '比較する1つ目の文字を入力してください');

        const [p1, p2] = [parseInput(input), parseInput(input2)];
        const [c1, c2] = [getCharFromInput(input), getCharFromInput(input2)];
        const [r1, r2] = await Promise.all([queryByUcs(p1.ucs, p1.ivs), queryByUcs(p2.ucs, p2.ivs)]);

        if (!r1.length || !r2.length) {
          return showEmpty(!r1.length && !r2.length ? '両方の文字がMJデータに見つかりません'
            : !r1.length ? `${c1} (${p1.ucs}) はMJデータに見つかりません` : `${c2} (${p2.ucs}) はMJデータに見つかりません`);
        }

        dom.mainEmpty.hidden = true;
        dom.variantsSection.hidden = false;
        renderCompareTable(r1, r2, c1, c2, p1.ucs, p1.ivs, p2.ucs, p2.ivs);
        [r1, r2].forEach((r, i) => {
          const p = i ? p2 : p1, c = i ? c2 : c1;
          const primary = r.find(d => isPrimaryResult(d, p.ucs, p.ivs, null)) || r[0];
          addToHistory(c, primary?.['MJ文字図形名']);
        });
        trackSearch(`${c1} vs ${c2}`);
        return;
      }

      if (!input) return showEmpty('文字を入力してください');

      // MJ name search
      if (isMjName(input)) {
        const mjName = input.toUpperCase();
        const results = await queryByMjName(mjName);
        if (!results.length) return showEmpty(`${mjName} はMJデータに見つかりません`);
        dom.mainEmpty.hidden = true;
        dom.variantsSection.hidden = false;
        renderVariantsTable(results, null, null, null, mjName);
        await renderRelated(results, null, null, mjName);
        trackSearch(mjName);
        return;
      }

      // Reading search
      if (isReading(input)) {
        const results = await queryByReading(input);
        if (!results.length) return showEmpty(`「${input}」に該当する文字が見つかりません`);
        dom.mainEmpty.hidden = true;
        dom.candidatesSection.hidden = false;
        renderCandidates(results, input);
        trackSearch(input);
        return;
      }

      // Character search
      const { ucs, ivs } = parseInput(input);
      const char = getCharFromInput(input);
      if (!char || !ucs) return showEmpty('文字を入力してください');

      const results = await queryByUcs(ucs, ivs);
      if (!results.length) return showEmpty(`${char} (${ucs}) はMJデータに見つかりません`);

      dom.mainEmpty.hidden = true;
      dom.variantsSection.hidden = false;
      renderVariantsTable(results, char, ucs, ivs);
      const primary = results.find(d => isPrimaryResult(d, ucs, ivs, null)) || results[0];
      addToHistory(char, primary?.['MJ文字図形名']);
      await renderRelated(results, ucs, ivs, null);
      trackSearch(char);
    };

    const debouncedUpdate = debounce(update, CONFIG.debounceMs);

    // ============================================================
    // Event Handlers
    // ============================================================
    dom.inputChar.addEventListener('focus', () => lastFocusedInput = dom.inputChar);
    dom.inputChar2.addEventListener('focus', () => lastFocusedInput = dom.inputChar2);

    const handleInput = () => {
      updateUrl(getCharFromInput(dom.inputChar.value), getCharFromInput(dom.inputChar2.value));
      debouncedUpdate();
    };
    dom.inputChar.addEventListener('input', handleInput);
    dom.inputChar2.addEventListener('input', handleInput);

    dom.compareToggle.addEventListener('change', () => {
      compareMode = dom.compareToggle.checked;
      dom.inputChar2.hidden = !compareMode;
      dom.compareVs.hidden = !compareMode;
      if (!compareMode) { dom.inputChar2.value = ''; updateUrl(dom.inputChar.value, null); }
      update();
    });

    dom.historyReset.addEventListener('click', () => { localStorage.removeItem(CONFIG.historyKey); renderHistory(); });

    dom.hopDepth.addEventListener('input', () => {
      dom.hopDepthValue.textContent = dom.hopDepth.value;
      if (lastRelatedParams) {
        const { results, inputUcs, inputIvs, inputMjName } = lastRelatedParams;
        renderRelated(results, inputUcs, inputIvs, inputMjName);
      }
    });

    // Resize handle
    let resizeState = null;
    dom.networkResizeHandle.addEventListener('pointerdown', e => {
      resizeState = { startY: e.clientY, startHeight: dom.networkGraph.clientHeight };
      dom.networkResizeHandle.setPointerCapture(e.pointerId);
      document.body.style.cursor = 'ns-resize';
      document.body.style.userSelect = 'none';
    });
    dom.networkResizeHandle.addEventListener('pointermove', e => {
      if (!resizeState) return;
      const newH = Math.max(200, Math.min(resizeState.startHeight + e.clientY - resizeState.startY, window.innerHeight - 100));
      dom.networkGraph.style.height = `${newH}px`;
      networkGraphHeight = newH;
      const svg = dom.networkGraph.querySelector('svg');
      if (svg) { svg.setAttribute('height', newH); svg.setAttribute('viewBox', `0 0 ${dom.networkGraph.clientWidth} ${newH}`); }
    });
    dom.networkResizeHandle.addEventListener('pointerup', () => {
      resizeState = null;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    });

    // ============================================================
    // Initialize
    // ============================================================
    renderHistory();
    Promise.all([initDuckDB(), initShrinkMap()])
      .then(() => {
        dom.dbStatus.removeAttribute('aria-busy');
        dom.dbStatus.textContent = 'MJ文字情報（約6万文字）と縮退マップを読み込みました';
        const params = new URLSearchParams(location.search);
        const [q, q2] = [params.get('q'), params.get('q2')];
        if (q) dom.inputChar.value = q;
        if (q2) {
          dom.inputChar2.value = q2;
          dom.compareToggle.checked = compareMode = true;
          dom.inputChar2.hidden = dom.compareVs.hidden = false;
        }
        update();
      })
      .catch(err => {
        console.error('Init failed:', err);
        dom.dbStatus.removeAttribute('aria-busy');
        dom.dbStatus.textContent = 'データの読み込みに失敗しました: ' + err.message;
      });
  </script>
</body>

</html>
